#summary Upgrading from Apache 2.2 to Apache 2.4

If you are upgrading from Apache 2.2 to Apache 2.3 or 2.4 you will need to be aware of several changes in the configuration and behavior of mod_authnz_external.

First, you must use `mod_authnz_external` version 3.3.  Previous versions will not work with Apache 2.3 or 2.4.

=== "`Require`" Command Syntax Changes ===

When using an external group checker, the syntax in Apache 2.2 and before was:

{{{
  GroupExternal <groupkeyword>
  Require group <groupname1> <groupname2> ...
}}}

In Apache 2.4, we need to replace the keyword `group` on the `Require` command with the keyword `external-group`, like this:

{{{
  GroupExternal <groupkeyword>
  Require external-group <groupname1> <groupname2> ...
}}}

Similarly, if you wanted to check if users were in the group that owns a file, the Apache 2.2 directive was:
{{{
  Require file-group
}}}
while in Apache 2.4 you must say:
{{{
  Require external-file-group
}}}

=== Per Configuration Authentication versus Per URI Authentication ===

In Apache an HTTP request for a URI may sometimes trigger other "sub-requests" for other URIs. For example, there might be an internal redirect to a different page or a .shtml file might use a server-side include to fetch other files. Mod_perl programs and the like can generate sub-requests very freely.

In previous versions of Apache, the authentication checks were redone each time a sub-request accessed a new URI.  In version 2.4, authentication modules repeat authentication checks for sub-requests only when it is for a resource with a different authentication configuration. So if you are doing a server-side include of a file that is in a directory where it has exactly the same authentication settings as the original, then the authentication check will only be done once.  This is good.

It might create a possible problem for a rare few users of mod_auth_external.  One of the environment variables passed to external authenticator programs is "URI". To quote myself:

   The URI variable is there because various people want it. Mostly it is useful
   not for authentication ("who is this person?") but for access control ("is this
   person permitted to do this?"), and good design usually dictates separating 
   those functions. Strictly speaking, an authenticator is not the right place
   to be doing access control. However, mod_authnz_external is 50% a 
   kludge-builder's tool, so we won't fuss if you want to break the rules.

Well, if broke the rule and wrote an external authenticator that uses the URI environment variable in a way that would lead it to giving different results for different URIs (not just for, say logging), and if you are doing anything at all that generates sub-requests, then you might be a bit messed up.

I think the number of people likely to be troubled by this issue is somewhere between "a couple" and "none". If you are among those people, you should either (1) redesign your authentication setup, or (2) edit the mod_authnz_external source code before installing it, changing three instances of "AP_AUTH_INTERNAL_PER_CONF" to "AP_AUTH_INTERNAL_PER_URI". I considered adding a configuration directive to mod_authnz_external that would let you switch the setting in a nicer way, but I suspect it would have to bypass the Apache API to work, and it's just not worth it.

=== Authoritativeness ===

In Apache 2.4 the moderation between multiple different access control modules is now controlled entirely by mod_auth_basic, not by the individual modules. This means that the old mod_auth_external directives,

{{{
   GroupExternalAuthoritative
   AuthzExternalAuthoritative
}}}

no longer exist.

=== Modifying Error Codes for Group Checking ===

In previous versions of mod_authnz_external, there was a directive which could
be used to send a different error code when an access control check failed:

{{{
   GroupExternalError 403
}}}

This also no longer exists.  The approximate same effect can be achieved with a new Apache directive:

{{{
   AuthzSendForbiddenOnFailure On
}}}

=== Use With Mod_authn_socache ===

Mod_authnz_external version 3.3.1 (currently available from svn only) and later can be used with the new Apache 2.4 mod_authn_socache module, which caches authentications. If you do this, then after a successful authentication, mod_socache will remember the user for a settable time (5 minutes by default) and not rerun the external authenticator again to check their password until after the timeout.  This can be a very substantial performance improvement.

It can also be a very substantial security problem.  One common use of mod_authnz_external is to authenticate from databases that are not readable by Apache, and should not be.  For example, if you are authenticating out of the a unix password file with pwauth, you don't want make the password file readable to Apache because then an Apache bug would risk exposing your entire password file to the net. But if you turn on caching with mod_authn_socache, then the cache it builds up is essentially an Apache-readable copy of the most sensitive data from your password file. With some settings, it may even be stored on disk rather than on memory. The only good thing you can say for it is that all the passwords in that cache will be encrypted (even if you are dopey enough not to encrypt them in your actual password database). But encryption is a pretty weak defense all by itself.

There might also be problems with cache latency. When a user changes his password, it may be five minutes before the old one expires out of the cache so that the new one can be used. If you delete a user's account, they might still be able to log in for another five minutes until their cache entry expires. There ought to be a way to flush the cache, but I don't think there is much you can do right now short of restarting Apache, and I'm not sure even that will always work. Still, I've been nagging the Apache people about this and maybe something will happen to change it.

So using mod_authnz_external with mod_authn_socache might be dumb, but, what the heck, when has mod_authnz_external ever passed up a chance to give you more rope to hang yourself with?

One more note: normally when you use mod_authn_socache with one of the standard Apache modules, a cache entry is created everytime it looks up a user's password in the database, even if the password they submitted wasn't the correct one.  With mod_authnz_external it only happens after
successful authentications. That's because mod_authnz_external doesn't have direct access to the password database. After a successful authentication we can fake-up something that looks to mod_authn_socache like some credentials out of a database by simple encrypting the password that the user sent us and pretending we got that out of a database. This means we don't get quite the performance gains that mod_authn_socache would give with something like mod_authn_dbd, but we get pretty close.

So here's how you do it. First you AuthBasicProvider statement should list both 'socache' and 'external', and it's important that 'socache' should be listed first, so that it tries to look up users in the cache before mod_authnz_external runs the authenticator:
{{{
       AuthBasicProvider socache external
}}}
Then you need to tell mod_authnz_external to start forging credentials for mod_authn_socache:
{{{
       AuthExternalProvideCache On
}}}
And you need to tell mod_authn_socache to accept credentials from mod_authnz_external:
{{{
       AuthnCacheProvideFor external
}}}
And that should do it. You should see many fewer runs of the external authenticator, and perhaps a slight decline in your overall security.