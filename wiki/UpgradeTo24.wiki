#summary Upgrading from Apache 2.2 to Apache 2.4

*NOTE: This page is a draft. A version of mod_authnz_external for Apache 2.3 / 2.4 is currently under development, but is not yet available. Please stay tuned.*

If you are upgrading from Apache 2.2 to Apache 2.4 you will need to be aware of several changes in the configuration and behavior of mod_authnz_external.

=== Require Syntax Changes ===

When using an external group checker, the syntax in Apache 2.2 and before was:

{{{
  GroupExternal <groupkeyword>
  Require group <groupname1> <groupname2> ...
}}}

In Apache 2.4, we need to replace the keyword `group` on the `Require` command with the keyword `external-group`, like this:

{{{
  GroupExternal <groupkeyword>
  Require external-group <groupname1> <groupname2> ...
}}}

Similarly, if you wanted to check if users were in the group that owns a file, the Apache 2.2 directive was:
{{{
  Require file-group
}}}
while in Apache 2.4 you must say:
{{{
  Require external-file-group
}}}

=== Per Configuration Authentication versus Per URI Authentication ===

In Apache an HTTP request for a URI may sometimes trigger other "sub-requests" for other URIs. For example, there might be an internal redirect to a different page or a .shtml file might use a server-side include to fetch other files. Mod_perl programs and the like can generate sub-requests very freely.

In previous versions of Apache, the authentication checks were redone each time a sub-request accessed a new URI.  In version 2.4, authentication modules repeat authentication checks for sub-requests only when it is for a resource with a different authentication configuration. So if you are doing a server-side include of a file that is in a directory where it has exactly the same authentication settings as the original, then the authentication check will only be done once.  This is good.

It might create a possible problem for a rare few users of mod_auth_external.  One of the environment variables passed to external authenticator programs is "URI". To quote myself:

   The URI variable is there because various people want it. Mostly it is useful
   not for authentication ("who is this person?") but for access control ("is this
   person permitted to do this?"), and good design usually dictates separating 
   those functions. Strictly speaking, an authenticator is not the right place
   to be doing access control. However, mod_authnz_external is 50% a 
   kludge-builder's tool, so we won't fuss if you want to break the rules.

Well, if broke the rule and wrote an external authenticator that uses the URI environment variable in a way that would lead it to giving different results for different URIs (not just for, say logging), and if you are doing anything at all that generates sub-requests, then you might be a bit messed up.

I think the number of people likely to be troubled by this issue is somewhere between "a couple" and "none". If you are among those people, you should either (1) redesign your authentication setup, or (2) edit the mod_authnz_external source code before installing it, changing three instances of "AP_AUTH_INTERNAL_PER_CONF" to "AP_AUTH_INTERNAL_PER_URI". I considered adding a configuration directive to mod_authnz_external that would let you switch the setting in a nicer way, but I suspect it would have to bypass the Apache API to work, and it's just not worth it.

=== Mod_authn_socache ===

In version 2.4, Apache introduces a new authentication module with can cache authentication credentials so they can be reused in later requests. This is especially attractive when you are authenticating out of some slow database like MySQL.

It'd be nice to use this with mod_authnz_external to, since external authentications are frequently slow. Unfortunately, it doesn't really do the job.

In a typical authentication, the page request would include a username and plain text password. We'd use the username as a key into our database to retrieve an encrypted copy of the correct password for the user. We then encrypt the submitted password, and compare it to the database password. If it matches, the authentication succeeds, otherwise it fails.

What mod_authn_socache caches is the username and the encrypted password from the database. On future requests, it checks the cache to see if it has an encrypted password for the user. If it does it encrypts the submitted password and compares them.

This is fine, but it doesn't work naturally with mod_authnz_external. In our case, all database accesses are handled by the external authenticator. All it returns to mod_authnz_external is a yes/no flag for whether or not the submitted password was correct. Mod_authnz_external doesn't have an encrypted database password to cache, and even if it somehow got that back from the external authenticator, there is no guarantee that it would be encrypted in a way that mod_authn_socache would understand.

So mod_authn_socache isn't usable with mod_authnz_external.

Unless maybe we get sneaky. If the external authenticator comes back and says that the authentication was valid, then we could take the user's submitted plain text password, encrypt it in some way that mod_authn_socache understands, and give that to mod_authn_socache to cache. Basically we'd be fooling mod_authn_socache into thinking we authenticated out of some normal Apache style authentication database.

I think that that could be made to work, but I haven't implemented it yet, being more concerned with just getting mod_authnz_external working in Apache 2.4 first.

=== Authoritativeness ===

In Apache 2.4 the moderation between multiple different access control modules is now controlled entirely by mod_auth_basic, not by the individual modules. This means that the old mod_auth_external directives,

{{{
   GroupExternalAuthoritative
   AuthzExternalAuthoritative
}}}

no longer exist.

=== Modifying Error Codes for Group Checking ===

In previous versions of mod_authnz_external, there was a directive which could
be used to send a different error code when an access control check failed:

{{{
   GroupExternalError 403
}}}

This also no longer exists.  The approximate same effect can be achieved with a new Apache directive:

{{{
   AuthzSendForbiddenOnFailure On
}}}